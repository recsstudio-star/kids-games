<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–î—Ä–æ–±–∏: —Ä–∞–∑–¥–µ–ª–∏ –∫–≤–∞–¥—Ä–∞—Ç</title>
  <style>
    :root {
      --bg: #0f172a;      /* slate-900 */
      --panel: #111827;   /* gray-900 */
      --ink: #e5e7eb;     /* gray-200 */
      --muted: #94a3b8;   /* slate-400 */
      --accent: #22c55e;  /* green-500 */
      --accent-2: #38bdf8;/* sky-400 */
      --danger: #ef4444;  /* red-500 */
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; display: grid; place-items: center; min-height: 100vh;
      background: radial-gradient(1200px 800px at 20% -10%, #1f2937 0%, #0b1022 60%, #050814 100%);
      color: var(--ink); font: 16px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
    }
    .app {
      width: min(92vw, 1000px);
      display: grid; gap: 16px;
    }
.back-to-menu-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            font-family: 'Comic Sans MS', cursive, Arial, sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255,107,107,0.3);
            z-index: 1000;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .back-to-menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(255,107,107,0.4);
        }
    .hdr {display:flex; align-items:center; justify-content:space-between; gap:12px}
    .title {font-size: clamp(18px, 2.4vw, 26px); font-weight: 700; letter-spacing:.2px}
    .controls {display:flex; gap:8px; flex-wrap:wrap}
    button, .toggle {
      background: linear-gradient(180deg, #1f2937, #0f172a);
      color: var(--ink); border: 1px solid #1f2937; border-radius: 14px;
      padding: 10px 14px; cursor: pointer; box-shadow: var(--shadow);
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      font-weight: 600; letter-spacing: .2px; user-select: none;
    }
    button:hover { transform: translateY(-1px); border-color:#334155 }
    button:active { transform: translateY(0) scale(.99) }
    button.primary { border-color: #14532d; background: linear-gradient(180deg,#14532d,#052e16) }
    button.danger { border-color: #7f1d1d; background: linear-gradient(180deg,#7f1d1d,#3f0a0a) }

    .board-wrap {
      background: #0b1226; border: 1px solid #1f2937; border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 16px; position: relative;
    }
    .hint { color: var(--muted); font-size: 14px; margin-top: 4px }

    /* Square container keeps aspect ratio */
    .square {
      position: relative;
      width: 100%;
      /* min height to make it usable on narrow screens */
      min-height: 320px;
      aspect-ratio: 1 / 1;
      border-radius: 12px;
      overflow: hidden;
    }
    svg { width: 100%; height: 100%; display:block; background: #0a0f20; border-radius: 12px; }

    /* Floating stats badge */
    .badge {
      position: absolute; right: 20px; top: 20px; z-index: 5;
      background: rgba(2,6,23,.75); border: 1px solid #172554; color: #93c5fd;
      backdrop-filter: blur(6px);
      padding: 8px 12px; border-radius: 10px; font-size: 12px;
    }

    .legend {font-size: 13px; color: var(--muted)}
  </style>
</head>
<body>
  <div class="app">
    <div class="hdr">
      <div class="title">–î—Ä–æ–±–∏: —Ä–∞–∑–¥–µ–ª–∏ –∫–≤–∞–¥—Ä–∞—Ç</div>
      <div class="controls">
        <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑—Ä–µ–∑">‚Ü∂ –û—Ç–º–µ–Ω–∏—Ç—å</button>
        <button id="resetBtn" class="danger" title="–ù–æ–≤–∞—è –∏–≥—Ä–∞ / –æ—á–∏—Å—Ç–∏—Ç—å">‚ü≤ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        <button id="viewBtn" class="primary" title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –≤–∏–¥ –º–µ—Ç–æ–∫">‚ë† –î–æ–ª–∏</button>
      </div>
    </div>
<button class="back-to-menu-button" onclick="goBackToMenu()">
        üè† –ù–∞–∑–∞–¥ –∫ –º–µ–Ω—é
    </button>
    <div class="board-wrap">
      <div class="square" id="square">
        <div class="badge" id="badge">–ß–∞—Å—Ç–µ–π: 1 ¬∑ –°—É–º–º–∞: 1</div>
        <svg id="svg" viewBox="0 0 1000 1000" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ" role="img"></svg>
      </div>
      <div class="hint">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –º—ã—à—å—é / –ø–∞–ª—å—Ü–µ–º <strong>–≤–Ω—É—Ç—Ä–∏ –∫–≤–∞–¥—Ä–∞—Ç–∞</strong>: –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∂–µ—Å—Ç ‚Äî –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ä–∞–∑—Ä–µ–∑, –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π ‚Äî –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π. –ú–µ—Ç–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –¥–æ–ª—é –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏ –æ—Ç —Ü–µ–ª–æ–≥–æ.</div>
      <div class="legend">–ü–æ–¥—Å–∫–∞–∑–∫–∏: –¥–≤–æ–π–Ω–æ–π —â–µ–ª—á–æ–∫ ‚Äî —Ä–∞–∑—Ä–µ–∑ –ø–æ —Ü–µ–Ω—Ç—Ä—É (–ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∂–µ—Å—Ç–∞). –ù–µ –¥–∞—ë–º –¥–µ–ª–∞—Ç—å —Ä–∞–∑—Ä–µ–∑—ã –±–ª–∏–∂–µ 3% –∫ —Å–æ—Å–µ–¥–Ω–µ–º—É.</div>
    </div>
  </div>

  <script>
    // ---------- Geometry state ----------
    const svg = document.getElementById('svg');
    const badge = document.getElementById('badge');
    const undoBtn = document.getElementById('undoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const viewBtn = document.getElementById('viewBtn');

    // Cut positions are in [0,1], with 0 and 1 being borders
    let xCuts = [0, 1];
    let yCuts = [0, 1];

    // History stack for undo
    const history = []; // entries: {axis:'x'|'y', t:number}

    // Label mode: 'fraction' | 'decimal' | 'percent'
    const modes = ['fraction','decimal','percent'];
    let modeIndex = 0;

    // Visual helpers
    const MIN_GAP = 0.03; // minimal distance between cuts

    // Layers inside SVG
    const layerCells = createSvg('g', {id:'cells'});
    const layerGrid  = createSvg('g', {id:'grid'});
    const layerCuts  = createSvg('g', {id:'cuts'});
    const layerHover = createSvg('g', {id:'hover'});
    svg.append(layerCells, layerGrid, layerCuts, layerHover);

    // ---------- Helpers ----------
    function createSvg(tag, attrs={}){
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
      return el;
    }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function insertCut(axis, t){
      // Normalize and avoid duplicates/too-close
      t = clamp(t, 0, 1);
      const arr = axis==='x' ? xCuts : yCuts;
      for (let i=0;i<arr.length;i++){
        const d = Math.abs(arr[i]-t);
        if (d < MIN_GAP) return false; // too close
      }
      arr.push(t);
      arr.sort((a,b)=>a-b);
      history.push({axis, t});
      return true;
    }

    function undo(){
      const e = history.pop();
      if(!e) return;
      const arr = e.axis==='x' ? xCuts : yCuts;
      const idx = arr.indexOf(e.t);
      if (idx> -1) arr.splice(idx,1);
    }

    // Rational approximation using continued fractions
    function toFraction(x, maxDen=24, eps=1e-6){
      if (x===0) return [0,1];
      if (x===1) return [1,1];
      let a = Math.floor(x), h1=1, k1=0, h= a, k=1, x1=x;
      while (Math.abs(x - h/k) > eps && k < maxDen){
        x1 = 1/(x1 - a);
        a = Math.floor(x1);
        const h2 = h1; h1 = h; h = a*h + h2;
        const k2 = k1; k1 = k; k = a*k + k2;
      }
      const num = Math.round(h), den = Math.round(k);
      // ensure within bounds
      if (den > maxDen){
        const n = Math.round(x*maxDen);
        return simplify(n, maxDen);
      }
      return simplify(num, den);
    }

    function gcd(a,b){ while(b){ [a,b] = [b, a%b]; } return Math.abs(a); }
    function simplify(n,d){ const g = gcd(n,d); return [n/g, d/g]; }

    function fmtLabel(f){
      const [num, den] = toFraction(f, 24);
      const frac = `${num}/${den}`;
      const dec  = (f).toFixed(3).replace(/\.0+$/,'').replace(/(\.\d*[1-9])0+$/,'$1');
      const pct  = Math.round(f*1000)/10 + '%';
      const kind = modes[modeIndex];
      return kind==='fraction' ? frac : (kind==='decimal' ? dec : pct);
    }

    function updateBadge(){
      const count = (xCuts.length-1)*(yCuts.length-1);
      badge.textContent = `–ß–∞—Å—Ç–µ–π: ${count} ¬∑ –°—É–º–º–∞: 1`;
    }

    // Palette for cells
    function palette(i){
      // Pastel HSL variations
      const h = (i*47) % 360;
      return `hsl(${h} 60% 22%)`;
    }
 function goBackToMenu() {
            window.location.href = 'index.html'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –∏–º—è —Ñ–∞–π–ª–∞ –≤–∞—à–µ–≥–æ –º–µ–Ω—é
        }
    function draw(){
      // Clear layers
      layerCells.innerHTML = '';
      layerGrid.innerHTML  = '';
      layerCuts.innerHTML  = '';

      // Draw grid lines
      const X = [...xCuts].sort((a,b)=>a-b).map(t=>Math.round(t*1000));
      const Y = [...yCuts].sort((a,b)=>a-b).map(t=>Math.round(t*1000));

      // Cells
      let idx=0;
      for (let yi=0; yi<Y.length-1; yi++){
        for (let xi=0; xi<X.length-1; xi++){
          const x = X[xi], y = Y[yi];
          const w = X[xi+1]-X[xi];
          const h = Y[yi+1]-Y[yi];
          const frac = (w/1000)*(h/1000);

          const rect = createSvg('rect', {x,y,width:w,height:h, rx:8, ry:8, fill: palette(idx), stroke:'#1f2937', 'stroke-width':1});
          layerCells.appendChild(rect);

          // Label background
          const label = fmtLabel(frac);
          const g = createSvg('g');
          const tx = x + w/2, ty = y + h/2;
          const bg = createSvg('rect', {x: tx-56, y: ty-16, width: 112, height: 32, rx: 10, ry: 10, fill:'rgba(2,6,23,0.55)', stroke:'#172554', 'stroke-width':1});
          const text = createSvg('text', {x: tx, y: ty+5, 'text-anchor':'middle', 'font-size': 28, fill:'#e5e7eb', 'font-weight':'700'});
          text.textContent = label;
          g.append(bg, text);
          layerCells.appendChild(g);

          idx++;
        }
      }

      // Draw cut lines (for emphasis)
      for (const t of xCuts){
        const x = Math.round(t*1000);
        const line = createSvg('line', {x1:x, y1:0, x2:x, y2:1000, stroke:'#0ea5e9', 'stroke-width': t===0||t===1 ? 3 : 2, 'stroke-dasharray': t===0||t===1 ? '': '6 6', opacity: t===0||t===1 ? .6 : .9});
        layerCuts.appendChild(line);
      }
      for (const t of yCuts){
        const y = Math.round(t*1000);
        const line = createSvg('line', {x1:0, y1:y, x2:1000, y2:y, stroke:'#22c55e', 'stroke-width': t===0||t===1 ? 3 : 2, 'stroke-dasharray': t===0||t===1 ? '': '6 6', opacity: t===0||t===1 ? .6 : .9});
        layerCuts.appendChild(line);
      }

      updateBadge();
    }

    // ---------- Interaction ----------
    let drag = null; // {startX,startY,lastX,lastY}
    let lastAxis = 'x';

    function svgPoint(evt){
      const pt = svg.createSVGPoint();
      const isTouch = evt.touches && evt.touches[0];
      const clientX = isTouch ? evt.touches[0].clientX : evt.clientX;
      const clientY = isTouch ? evt.touches[0].clientY : evt.clientY;
      pt.x = clientX; pt.y = clientY;
      const m = svg.getScreenCTM().inverse();
      const p = pt.matrixTransform(m);
      // Normalize to [0,1]
      const x = clamp(p.x/1000, 0, 1);
      const y = clamp(p.y/1000, 0, 1);
      return {x,y};
    }

    function startDrag(evt){
      evt.preventDefault();
      const {x,y} = svgPoint(evt);
      drag = {startX:x, startY:y, lastX:x, lastY:y};
    }
    function moveDrag(evt){
      if(!drag) return;
      const {x,y} = svgPoint(evt);
      drag.lastX = x; drag.lastY = y;
      renderHover();
    }
    function endDrag(evt){
      if(!drag) return;
      const {startX, startY, lastX, lastY} = drag;
      const dx = lastX - startX, dy = lastY - startY;
      const axis = Math.abs(dx) >= Math.abs(dy) ? 'y' : 'x'; // dominant motion defines cut perpendicular: horizontal motion -> vertical cut? No: we want vertical motion => horizontal cut.
      // Correction: dominant direction defines same-orientation cut
      const ori = Math.abs(dx) >= Math.abs(dy) ? 'x' : 'y'; // 'x' => vertical cut at x=t; 'y' => horizontal cut at y=t
      lastAxis = ori;
      const t = ori==='x' ? clamp((startX+lastX)/2, 0, 1) : clamp((startY+lastY)/2, 0, 1);
      insertCut(ori, t);
      drag = null;
      layerHover.innerHTML = '';
      draw();
    }

    function renderHover(){
      layerHover.innerHTML = '';
      if(!drag) return;
      const {startX, startY, lastX, lastY} = drag;
      const dx = lastX - startX, dy = lastY - startY;
      const ori = Math.abs(dx) >= Math.abs(dy) ? 'x' : 'y';
      const t = ori==='x' ? clamp((startX+lastX)/2, 0, 1) : clamp((startY+lastY)/2, 0, 1);
      const pos = Math.round(t*1000);
      const line = ori==='x'
        ? createSvg('line', {x1:pos, y1:0, x2:pos, y2:1000, stroke:'#60a5fa', 'stroke-width':3, 'stroke-dasharray':'10 8', opacity:.9})
        : createSvg('line', {x1:0, y1:pos, x2:1000, y2:pos, stroke:'#86efac', 'stroke-width':3, 'stroke-dasharray':'10 8', opacity:.9});
      layerHover.appendChild(line);
    }

    // Double-click: cut through center along last orientation
    function dbl(evt){
      const {x,y} = svgPoint(evt);
      const t = lastAxis==='x' ? x : y; // place near pointer
      insertCut(lastAxis, t);
      draw();
    }

    // Buttons
    undoBtn.addEventListener('click', ()=>{ undo(); draw(); });
    resetBtn.addEventListener('click', ()=>{ xCuts=[0,1]; yCuts=[0,1]; history.length=0; draw(); });
    viewBtn.addEventListener('click', ()=>{
      modeIndex = (modeIndex+1)%modes.length;
      viewBtn.textContent = modeIndex===0 ? '‚ë† –î–æ–ª–∏' : (modeIndex===1 ? '‚ë† –î–µ—Å—è—Ç–∏—á–Ω—ã–µ' : '‚ë† –ü—Ä–æ—Ü–µ–Ω—Ç—ã');
      draw();
    });

    // Pointer events
    svg.addEventListener('mousedown', startDrag);
    svg.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
    svg.addEventListener('touchstart', startDrag, {passive:false});
    svg.addEventListener('touchmove', moveDrag, {passive:false});
    svg.addEventListener('touchend', endDrag);

    svg.addEventListener('dblclick', dbl);

    // Initial draw
    draw();
  </script>
</body>
</html>
