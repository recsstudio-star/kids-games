<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>–ò–≥—Ä–∞ ‚Äî –¥—Ä–æ–±–∏ (–¥–µ–ª–∏–º –∫–≤–∞–¥—Ä–∞—Ç)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: Inter, Roboto, Arial; margin: 24px; color:#111; }
  h1 { margin:0 0 8px 0; font-size:18px; }
  #container { display:flex; gap:20px; align-items:flex-start; }
  canvas { border:1px solid #888; background:#fff; cursor:crosshair; }
  #controls { min-width:260px; }
  button { padding:8px 12px; margin-top:8px; cursor:pointer; }
  .hint { margin-top:12px; font-size:13px; color:#333; }
  ul { margin:8px 0 0 18px; }
  .back-to-menu-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            font-family: 'Comic Sans MS', cursive, Arial, sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255,107,107,0.3);
            z-index: 1000;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .back-to-menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(255,107,107,0.4);
        }
	.part-list { margin-top:12px; font-size:13px; max-height:360px; overflow:auto; }
  .part-item { padding:6px 8px; border-radius:6px; margin-bottom:6px; color:#fff; display:flex; justify-content:space-between; align-items:center; }
  .small { font-size:12px; color:#555; margin-top:8px; }
</style>
</head>
<body>
  <h1>–ò–≥—Ä–∞ ‚Äî –¥—Ä–æ–±–∏: –¥–µ–ª–∏–º –∫–≤–∞–¥—Ä–∞—Ç –º—ã—à—å—é</h1>
	<button class="back-to-menu-button" onclick="goBackToMenu()">
        üè† –ù–∞–∑–∞–¥ –∫ –º–µ–Ω—é
    </button>
  <div id="container">
    <canvas id="board" width="600" height="600" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ"></canvas>
    <div id="controls">
      <div><strong>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è</strong></div>
      <div class="hint">
        –ù–∞–∂–º–∏—Ç–µ –∏ —É–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –≤–Ω—É—Ç—Ä–∏ –∫–≤–∞–¥—Ä–∞—Ç–∞, –ø–æ—Ç—è–Ω–∏—Ç–µ –∏ –æ—Ç–ø—É—Å—Ç–∏—Ç–µ ‚Äî —Å–æ–∑–¥–∞—ë—Ç—Å—è –ø—Ä—è–º–æ–π –Ω–∞–¥—Ä–µ–∑ –ø–æ –ª–∏–Ω–∏–∏.
        –ö–∞–∂–¥–∞—è —á–∞—Å—Ç—å –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç—Å—è –∏ –ø–æ–ª—É—á–∞–µ—Ç –¥—Ä–æ–±–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: —á–∞—Å—Ç—å –æ—Ç —Ü–µ–ª–æ–≥–æ. –ú–æ–∂–Ω–æ –¥–µ–ª–∞—Ç—å –º–Ω–æ–≥–æ –Ω–∞–¥—Ä–µ–∑–æ–≤.
      </div>
      <button id="resetBtn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
      <div class="small">–û—Ä–∏–≥–∏–Ω–∞–ª: –µ–¥–∏–Ω–∏—á–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç (1).</div>
      <div class="part-list" id="parts"></div>
    </div>
  </div>

<script>
// --- –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∏ –¥—Ä–æ–±–µ–π ---
function goBackToMenu() {
            window.location.href = 'index.html'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –∏–º—è —Ñ–∞–π–ª–∞ –≤–∞—à–µ–≥–æ –º–µ–Ω—é
        }
function areaOf(poly) {
  // poly: [{x,y}, ...]  - oriented polygon
  let a = 0;
  for (let i = 0; i < poly.length; i++) {
    let j = (i+1)%poly.length;
    a += poly[i].x*poly[j].y - poly[j].x*poly[i].y;
  }
  return Math.abs(a)/2;
}

function lineFromPoints(a,b) {
  // return normalized line coefficients ax + by + c = 0
  let A = b.y - a.y;
  let B = a.x - b.x;
  let C = -(A*a.x + B*a.y);
  // normalize (optional)
  let norm = Math.hypot(A,B) || 1;
  return {A: A/norm, B: B/norm, C: C/norm};
}

function sideValue(line, p){ // sign value
  return line.A * p.x + line.B * p.y + line.C;
}

// Sutherland-Hodgman clip polygon by half-plane (keep side >= 0 if keepPositive true)
function clipPolygonByHalfPlane(poly, line, keepPositive=true){
  let res = [];
  let n = poly.length;
  if (n===0) return res;
  for (let i=0;i<n;i++){
    let cur = poly[i];
    let next = poly[(i+1)%n];
    let sc = sideValue(line, cur);
    let sn = sideValue(line, next);
    let insideC = keepPositive ? sc >= -1e-9 : sc <= 1e-9;
    let insideN = keepPositive ? sn >= -1e-9 : sn <= 1e-9;
    if (insideC) res.push(cur);
    if (insideC ^ insideN) {
      // compute intersection point
      let t = sc - sn;
      if (Math.abs(t) > 1e-12) {
        let u = sc / (sc - sn); // fraction along segment cur->next where sign crosses
        let ix = cur.x + (next.x - cur.x) * u;
        let iy = cur.y + (next.y - cur.y) * u;
        res.push({x: ix, y: iy});
      }
    }
  }
  // Remove near-duplicate consecutive points
  res = res.filter((p,i)=> {
    let q = res[(i+res.length-1)%res.length];
    return !(Math.hypot(p.x-q.x,p.y-q.y) < 1e-8);
  });
  return res;
}

// approximate real value as simplified fraction with bounded denominator
function approxFraction(x, maxDen=48) {
  if (!isFinite(x)) return null;
  let sign = x < 0 ? -1 : 1;
  x = Math.abs(x);
  const eps = 1e-8;
  if (Math.abs(x) < eps) return {n:0,d:1};
  // continued fraction
  let a0 = Math.floor(x);
  let fractions = [{n:a0, d:1}];
  let f0 = a0;
  let rem = x - a0;
  if (rem < eps) return {n: sign*a0, d:1};
  let p0 = 1, q0 = 0;
  let p1 = a0, q1 = 1;
  let maxIter = 50;
  let a = a0;
  let r = rem;
  for (let i=0;i<maxIter;i++){
    if (r===0) break;
    a = Math.floor(1/r);
    let p2 = a*p1 + p0;
    let q2 = a*q1 + q0;
    if (q2 > maxDen) {
      // try best approximation by limiting last step
      let k = Math.floor((maxDen - q0) / q1);
      if (k <= 0) break;
      p2 = k*p1 + p0;
      q2 = k*q1 + q0;
      return reduceFrac(sign*p2, q2);
    }
    let value = p2/q2;
    if (Math.abs(value - x) < 1e-9) return reduceFrac(sign*p2, q2);
    p0 = p1; q0 = q1;
    p1 = p2; q1 = q2;
    r = 1/r - a;
  }
  return reduceFrac(sign*p1, q1);
}

function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){[a,b]=[b,a%b]}; return a; }
function reduceFrac(n,d){ if (d===0) return {n:1,d:0}; let g = gcd(n,d); return {n: n/g, d: d/g}; }

// generate visually pleasant colors
function makeColors(n){
  const colors = [];
  for (let i=0;i<n;i++){
    let h = Math.floor(360 * (i / (n||1)));
    colors.push(`hsl(${h} 80% 50%)`);
  }
  return colors;
}

// --- –ò–≥—Ä–∞: –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –º–∞—Å—Å–∏–≤ —á–∞—Å—Ç–µ–π –∫–∞–∫ –ø–æ–ª–∏–≥–æ–Ω—ã –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö 0..1 (–Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω)
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', {alpha:false});
let W = canvas.width, H = canvas.height;
const pad = 40; // margin around square
let sq = {x: pad, y: pad, size: Math.min(W,H) - pad*2}; // pixel coordinates
const unitArea = 1; // logical area of full square
let parts = []; // each part: {poly: [{x,y} logical 0..1], color}
let colors = [];

function resetGame() {
  // square in logical coordinates [0,1] x [0,1]
  parts = [{
    poly: [{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:0,y:1}]
  }];
  colors = makeColors(8);
  render();
  updatePartsList();
}

function toPixel(p) {
  return {x: sq.x + p.x * sq.size, y: sq.y + (1-p.y) * sq.size};
}
function toLogical(pt) {
  return {x: (pt.x - sq.x) / sq.size, y: 1 - (pt.y - sq.y) / sq.size};
}

function render() {
  // clear
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,W,H);
  // draw square boundary
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1;
  ctx.strokeRect(sq.x-0.5, sq.y-0.5, sq.size+1, sq.size+1);

  // draw parts
  let colorsLocal = makeColors(parts.length);
  parts.forEach((p, idx)=>{
    if (!p.poly || p.poly.length < 3) return;
    ctx.beginPath();
    p.poly.forEach((v,i)=>{
      let pv = toPixel(v);
      if (i===0) ctx.moveTo(pv.x, pv.y);
      else ctx.lineTo(pv.x, pv.y);
    });
    ctx.closePath();
    ctx.fillStyle = colorsLocal[idx];
    ctx.globalAlpha = 0.9;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 1;
    ctx.stroke();

    // label: centroid + fraction text
    let cx = 0, cy = 0;
    for (let v of p.poly) { cx += v.x; cy += v.y; }
    cx /= p.poly.length; cy /= p.poly.length;
    let area = areaOf(p.poly) / unitArea;
    let frac = approxFraction(area, 48);
    let label = (frac ? (frac.n + '/' + frac.d) : area.toFixed(3));
    let pv = toPixel({x:cx, y:cy});
    // draw label with contrasting stroke
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 3;
    ctx.strokeText(label, pv.x, pv.y);
    ctx.fillText(label, pv.x, pv.y);
  });

  // small overlay info
  ctx.fillStyle = '#000';
  ctx.font = '12px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('–ß–∏—Å–ª–æ —á–∞—Å—Ç–µ–π: ' + parts.length, 8, H - 8);
}

function updatePartsList(){
  const el = document.getElementById('parts');
  el.innerHTML = '';
  const totalArea = 1; // normalized
  parts.forEach((p,i)=>{
    let a = areaOf(p.poly);
    let frac = approxFraction(a/totalArea, 48);
    let txt = frac ? `${frac.n}/${frac.d}` : (a/totalArea).toFixed(4);
    let div = document.createElement('div');
    div.className = 'part-item';
    div.style.background = makeColors(parts.length)[i];
    div.innerHTML = `<div>–ß–∞—Å—Ç—å ${i+1}</div><div>${txt} (${(a/totalArea*100).toFixed(2)}%)</div>`;
    el.appendChild(div);
  });
}

// apply cut line (in logical coords) to current parts
function applyCut(p1, p2) {
  // ignore degenerate small drags
  if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < 1e-5) return;
  let line = lineFromPoints(p1,p2); // normalized
  let newParts = [];
  for (let part of parts) {
    let poly = part.poly;
    // clip for positive side and negative side
    let a = clipPolygonByHalfPlane(poly, line, true);
    let b = clipPolygonByHalfPlane(poly, line, false);
    if (a.length >= 3 && b.length >= 3) {
      // cut produced two polygons
      newParts.push({poly: a});
      newParts.push({poly: b});
    } else {
      // no cut: keep original
      newParts.push({poly: poly});
    }
  }
  // merge very tiny polygons (area threshold)
  newParts = newParts.filter(p => areaOf(p.poly) > 1e-7);
  parts = newParts;
  render();
  updatePartsList();
}

// --- Mouse interaction for drawing cut ---
let dragging = false;
let startPt = null;
let currentMouse = null;

canvas.addEventListener('mousedown', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const pt = {x: ev.clientX - rect.left, y: ev.clientY - rect.top};
  // only start if inside square
  if (pt.x >= sq.x && pt.x <= sq.x+sq.size && pt.y >= sq.y && pt.y <= sq.y+sq.size) {
    dragging = true;
    startPt = toLogical(pt);
    currentMouse = pt;
  }
});

canvas.addEventListener('mousemove', (ev)=>{
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  currentMouse = {x: ev.clientX - rect.left, y: ev.clientY - rect.top};
  // draw preview
  render();
  // draw preview line
  ctx.save();
  ctx.strokeStyle = 'rgba(0,0,0,0.7)';
  ctx.lineWidth = 2;
  ctx.setLineDash([8,6]);
  ctx.beginPath();
  ctx.moveTo(startPt ? toPixel(startPt).x : currentMouse.x, startPt ? toPixel(startPt).y : currentMouse.y);
  ctx.lineTo(currentMouse.x, currentMouse.y);
  ctx.stroke();
  ctx.restore();
});

canvas.addEventListener('mouseup', (ev)=>{
  if (!dragging) return;
  dragging = false;
  const rect = canvas.getBoundingClientRect();
  const pt = {x: ev.clientX - rect.left, y: ev.clientY - rect.top};
  // compute logical endpoints but extend line across the whole square (we only need two points on plane)
  let pA = startPt;
  let pB = toLogical(pt);
  applyCut(pA, pB);
  startPt = null;
  currentMouse = null;
});

canvas.addEventListener('mouseleave', (ev)=>{
  if (dragging) {
    dragging = false;
    startPt = null;
    currentMouse = null;
    render();
  }
});

// handle resizing for crispness (static canvas size used; can add responsiveness later)
function init() {
  W = canvas.width; H = canvas.height;
  sq = {x: pad, y: pad, size: Math.min(W,H) - pad*2};
  resetGame();
}

document.getElementById('resetBtn').addEventListener('click', ()=> resetGame());

// initialize
init();

// Accessibility: keyboard hint to reset with R
window.addEventListener('keydown', (e)=>{
  if (e.key.toLowerCase() === 'r') resetGame();
});
</script>
</body>
</html>
